%% How to organize recording data

% Use this file to generate an example.

% Individual recording sessions should be saved by generating: 
% events <struct>, neurons <cell>, electrodes <...>, regions <struct>.
% These files should be savend using the following stucture: 
% /study_Name/data/sorted/subject/day. See hotoOrganizeData.docx 

% Neurophys lives in the files events.mat, conditions.mat, neurons.mat, electrodes.mat (lfp.mat)

% needed only for this doc
trials = 10; % number of trials per session (e.g. 10) 

%% events <struct>
%   fields code <cell><numtrials,1>
%          time <cell><numtrials,1>

% Save event codes in a struct contsisting of two fields, code and time, that are organized in individual trials. 
% The timestamps of event codes (events.time) should be aligned to start of ITI. Thus, each trial starts with ITI = 0. 
% (All timestamps substracted with timestamp of ITI)

% these are the 'raw' event codes
events = struct('code',[],'time',[]);
for n = 1 : trials
    events.code{n,1} = [1; 2; 3; 4; 5]; % example event codes per trial in column vector
    events.time{n,1} = [0; 0.2; 0.4; 0.6; 0.8]; % example timestamps for each event code per trial in column vector
end

%% conditions <struct>
% generated by toolbox function
% these is the first processing step of the event-codes. can be used e.g. for logical indexing of the trials

% == we should agree on some names that are used reliably, but that can be
% expanded depending on the experiment.

condition = struct('correct',[],'incorrect',[], 'omission',[], ...
    'response',[], 'aborted',[],'stimulus',[]);
% logicals, one for eacch trial, these are suggestions but the names should 
% be used whereever they apply in a given experiment/ analysis.
% Additional fields will also be required for each individual experiment.
condition.correct   = [1 0 1 0 1 0 0 0 0 0]';    % logical: correct response
condition.incorrect = [0 0 0 0 0 1 1 1 1 1]';    % logical: incorrect response
condition.omission  = [0 1 0 0 0 0 0 0 0 0]';    % logical: no reponse
condition.response  = [1 0 1 1 2 2 1 1 4 3]';   % different types of response
condition.aborted   = nan(10,1);                % this is not possible in the current experiment
condition.stimulus  = 1:10;                     % stimulus 1 to 10

% = more predefined?
% = should each experiment have the agreed fields for compattibility even
% if they don't make sense in the current experiment?

%% neurons <cell>
% Save neuronal activity (spikes) in a cell array containing all neurons recorded in one session. 
% The spiketimes should be sorted in column vectors per trial and also aligned to start of ITI. 

m = 3;                  % number of neurons per recording session (e.g. 3)
neurons = cell(m,1);
for i = 1 : m
    neurons{i} = cell(trials,1);    % trials = number of trials per session 
    for n = 1 : trials
        neurons{i,1}{n,1} = [0.1; 0.34; 0.65]; % column vector with all spiketimes per trial
    end
end

%% electrodes <struct>
% not session dependent but surgery dependent
elInfo.vendor       = 'neuronexus';    
elInfo.elSerial     = {'hans', 'emil'};     % neuronexus serial
% elInfo.shankSpacing = {[],[]};            % distance shanks on each electrode
elInfo.region       = {'ncl', 'niml'}; 
% surgery coordinates relative to whioch shank?
elInfo.apMlDv       = {[],[]};
% elInfo.channelSpacing      = {[],[]};
% elInfo.channelMapping      = {[],[]};
% elInfo.spacing             = {[],[]};

% could be session dependent
elInfo.impedance    = {[],[]};

% info organized by each neuron for indexing
for i =1:m
    elInfo.neurons(i).elIndex   % index into elSerial 
    elInfo.neurons(i).elShank   % shank nr on electrode
    elInfo.neurons(i).channel   % channel nr on electrode (shank)
    elInfo.neurons(i).depth     % depth of current recording channel
%     elInfo.neurons(i).sortQuality
end
